var documenterSearchIndex = {"docs":
[{"location":"#MedEye3d.jl","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"","category":"section"},{"location":"#MedEye3d","page":"MedEye3d.jl","title":"MedEye3d","text":"","category":"section"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"Main goal of the package is conviniently visualize 3d medical imaging to make segmentation simpler","category":"page"},{"location":"#Some-oficial-introduction-you-can-skip-it","page":"MedEye3d.jl","title":"Some oficial introduction - you can skip it","text":"","category":"section"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"Image segmentation in the medical domain has mul-tiple use cases.  Most importantly it enables delin-eation of physiological and pathological structures,in  order  to  confirm  or  reject  some  diagnostic  hy-pothesis.   In  case  of  all  segmentation  problems,  avery  important  step  in  evaluation  of  the  segmen-tation algorithm output is visual inspection.  Suchinspection enables researchers that are responsiblefor creating and or evaluating developed algorithmsto easily spot problems, and compare different algo-rithms in more detailed ways than can be achievedby usage of segmentation metrics alone.  Howeverin order for such in development visual evaluationto be useful it needs to meet some usage criteria.It needs to be easily integrable to the program-ming language and libraries used by researchers.Performance  of  the  tool  must  be  adequate  inorder to suit the iterative process of algorithm de-velopment and refinement.Representation accuracy must be sufficient forthe task at hand.  It should not require an exces-sive amount of computational resources, in order tominimize its influence on running algorithms.Support for in memory data structures (arrays)should be convenient. Needs  to  provide  possibility  of  simple  manualannotations,  on given mask and ability to controlvisibility and visual representation of given mask.Should provide also the possibility to display somemetadata in text format like segmentation metricsfor example DICE score.Ideally  it  should  be  also  open  source  and  welldocumented in order to enable users to modify itaccording to the task at hand.In  order  to  address  all  of  those  issues  in  themedical domain and Julia language ecosystem thedescribed below package was developed.","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"Image below just represents limitless possibilities of color ranges, and that thanks to OpenGl even theorethically complex data to display will render nearly instantenously. ","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"(Image: image)","category":"page"},{"location":"#","page":"MedEye3d.jl","title":"","text":"","category":"section"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"Below the functionality of the package will be described on the basis of some examples In case of any questions, feature requests, or propositions of cooperation  post them here on Github or contact me via LinkedIn linkedin.com/in/jakub-mitura-7b2013151","category":"page"},{"location":"#Defining-Helper-Functions-and-imports","page":"MedEye3d.jl","title":"Defining Helper Functions and imports","text":"","category":"section"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"#I use Simple ITK as most robust\nusing NuclearMedEye, Conda,PyCall,Pkg\n\nConda.pip_interop(true)\nConda.pip(\"install\", \"SimpleITK\")\nConda.pip(\"install\", \"h5py\")\nsitk = pyimport(\"SimpleITK\")\nnp= pyimport(\"numpy\")\n\nimport NuclearMedEye\nimport NuclearMedEye.ForDisplayStructs\nimport NuclearMedEye.ForDisplayStructs.TextureSpec\nusing ColorTypes\nimport NuclearMedEye.SegmentationDisplay\n\nimport NuclearMedEye.DataStructs.ThreeDimRawDat\nimport NuclearMedEye.DataStructs.DataToScrollDims\nimport NuclearMedEye.DataStructs.FullScrollableDat\nimport NuclearMedEye.ForDisplayStructs.KeyboardStruct\nimport NuclearMedEye.ForDisplayStructs.MouseStruct\nimport NuclearMedEye.ForDisplayStructs.ActorWithOpenGlObjects\nimport NuclearMedEye.OpenGLDisplayUtils","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"Helper functions used to upload data - those will be enclosed (with many more) in a package that Is currently in development - 3dMedPipe ","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"\"\"\"\ngiven directory (dirString) to file/files it will return the simple ITK image for futher processing\nisMHD when true - data in form of folder with dicom files\nisMHD  when true - we deal with MHD data\n\"\"\"\nfunction getImageFromDirectory(dirString,isMHD::Bool, isDicomList::Bool)\n    #simpleITK object used to read from disk \n    reader = sitk.ImageSeriesReader()\n    if(isDicomList)# data in form of folder with dicom files\n        dicom_names = reader.GetGDCMSeriesFileNames(dirString)\n        reader.SetFileNames(dicom_names)\n        return reader.Execute()\n    elseif(isMHD) #mhd file\n        return sitk.ReadImage(dirString)\n    end\nend#getPixelDataAndSpacing\n\n\"\"\"\nbecouse Julia arrays is column wise contiguus in memory and open GL expects row wise we need to rotate and flip images \npixels - 3 dimensional array of pixel data \n\"\"\"\nfunction permuteAndReverse(pixels)\n    pixels=  permutedims(pixels, (3,2,1))\n    sizz=size(pixels)\n    for i in 1:sizz[1]\n        pixels[i,:,:] =  reverse(pixels[i,:,:])\n    end# \n  \n    for i in 1:sizz[2]\n    pixels[:,i,:] =  reverse(pixels[:,i,:])\n    end# \n    return pixels\n  end#permuteAndReverse\n\n\"\"\"\ngiven simple ITK image it reads associated pixel data - and transforms it by permuteAndReverse functions\nit will also return voxel spacing associated with the image\n\"\"\"\nfunction getPixelsAndSpacing(image)\n    pixelsArr = np.array(sitk.GetArrayViewFromImage(image))# we need numpy in order for pycall to automatically change it into julia array\n    spacings = image.GetSpacing()\n    return ( permuteAndReverse(pixelsArr), spacings  )\nend#getPixelsAndSpacing","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"Directories - obviously you need to provide path to place where it is stored on your disk. You can download PET/CT data from. You can download example data from https://wwsi365-my.sharepoint.com/:f:/g/personal/s9956jmmswwsiedupl/EstYmEuRHqZNlFIlPBzhbQIBvMwQBJks2lUcCSWgwCYSOg?e=nfW95Q","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"# directories of PET/CT Data - from https://wiki.cancerimagingarchive.net/display/Public/Head-Neck-PET-CT\ndirOfExample =\"C:\\\\GitHub\\\\JuliaMedPipe\\\\data\\\\PETphd\\\\slicerExp\\\\all17\\\\bad17NL-bad17NL\\\\20150518-PET^1_PET_CT_WholeBody_140_70_Recon (Adult)\\\\4-CT AC WB  1.5  B30f\"\ndirOfExamplePET =\"C:\\\\GitHub\\\\JuliaMedPipe\\\\data\\\\PETphd\\\\slicerExp\\\\all17\\\\bad17NL-bad17NL\\\\20150518-PET^1_PET_CT_WholeBody_140_70_Recon (Adult)\\\\3-PET WB\"\n\n# in most cases dimensions of PET and CT data arrays will be diffrent in order to make possible to display them we need to resample and make dimensions equal\nimagePET= getImageFromDirectory(dirOfExamplePET,false,true)\nctImage= getImageFromDirectory(dirOfExample,false,true)\npet_image_resampled = sitk.Resample(imagePET, ctImage)\n\nctPixels, ctSpacing = getPixelsAndSpacing(ctImage)\n# In my case PET data holds 64 bit floats what is unsupported by Opengl\npetPixels, petSpacing =getPixelsAndSpacing(pet_image_resampled)\npetPixels = Float32.(petPixels)\n\n# we need to pass some metadata about image array size and voxel dimensions to enable proper display\ndatToScrollDimsB= NuclearMedEye.ForDisplayStructs.DataToScrollDims(imageSize=  size(ctPixels) ,voxelSize=ctSpacing, dimensionToScroll = 3 );\n# example of texture specification used - we need to describe all arrays we want to display, to see all possible configurations look into TextureSpec struct docs .\ntextureSpecificationsPETCT = [\n  TextureSpec{Float32}(\n      name = \"PET\",\n      isNuclearMask=true,\n      # we point out that we will supply multiple colors\n      isContinuusMask=true,\n      #by the number 1 we will reference this data by for example making it visible or not\n      numb= Int32(1),\n      colorSet = [RGB(0.0,0.0,0.0),RGB(1.0,1.0,0.0),RGB(1.0,0.5,0.0),RGB(1.0,0.0,0.0) ,RGB(1.0,0.0,0.0)]\n      #display cutoff all values below 200 will be set 2000 and above 8000 to 8000 but only in display - source array will not be modified\n      ,minAndMaxValue= Float32.([200,8000])\n     ),\n  TextureSpec{UInt8}(\n      name = \"manualModif\",\n      numb= Int32(2),\n      color = RGB(0.0,1.0,0.0)\n      ,minAndMaxValue= UInt8.([0,1])\n      ,isEditable = true\n     ),\n\n     TextureSpec{Int16}(\n      name= \"CTIm\",\n      numb= Int32(3),\n      isMainImage = true,\n      minAndMaxValue= Int16.([0,100]))  \n];\n# We need also to specify how big part of the screen should be occupied by the main image and how much by text fractionOfMainIm= Float32(0.8);\nfractionOfMainIm= Float32(0.8);\n\"\"\"\nIf we want to display some text we need to pass it as a vector of SimpleLineTextStructs - utility function to achieve this is \ntextLinesFromStrings() where we pass resies of strings, if we want we can also edit those structs to controll size of text and space to next line look into SimpleLineTextStruct doc\nmainLines - will be displayed over all slices\nsupplLines - will be displayed over each slice where is defined - below just dummy data\n\"\"\"\nimport NuclearMedEye.DisplayWords.textLinesFromStrings\n\nmainLines= textLinesFromStrings([\"main Line1\", \"main Line 2\"]);\nsupplLines=map(x->  textLinesFromStrings([\"sub  Line 1 in $(x)\", \"sub  Line 2 in $(x)\"]), 1:size(ctPixels)[3] );","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"If we want to pass 3 dimensional array of scrollable data we need to supply it via vector ThreeDimRawDat's struct utility function to make creation of those easier is getThreeDims which creates series of ThreeDimRawDat from list of tuples where     first entry is String and second entry is 3 dimensional array with data      strings needs to be the same as we  defined in texture specifications at the bagining     data arrays needs to be o the same size and be of the same type we specified in texture specification","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"import NuclearMedEye.StructsManag.getThreeDims\n\ntupleVect = [(\"PET\",petPixels) ,(\"CTIm\",ctPixels),(\"manualModif\",zeros(UInt8,size(petPixels)) ) ]\nslicesDat= getThreeDims(tupleVect )\n\"\"\"\nHolds data necessary to display scrollable data\n\"\"\"\nmainScrollDat = FullScrollableDat(dataToScrollDims =datToScrollDimsB\n                                 ,dimensionToScroll=1 # what is the dimension of plane we will look into at the beginning for example transverse, coronal ...\n                                 ,dataToScroll= slicesDat\n                                 ,mainTextToDisp= mainLines\n                                 ,sliceTextToDisp=supplLines );\n","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"This function prepares all for display; 1000 in the end is responsible for setting window width for more look into SegmentationDisplay.coordinateDisplay","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"SegmentationDisplay.coordinateDisplay(textureSpecificationsPETCT ,fractionOfMainIm ,datToScrollDimsB ,1000);","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"As all is ready we can finally display image ","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"Main.SegmentationDisplay.passDataForScrolling(mainScrollDat);","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"So after invoking this function one should see image sth like below","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"(Image: image)","category":"page"},{"location":"#Interactions","page":"MedEye3d.jl","title":"Interactions","text":"","category":"section"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"Next all Interactions are done either by mouse or by keyboard shortcuts","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"left click and drag - will mark active texture (look below - set with alt ...)      if it is set to be modifiable in the texture specifications, to the set value and size (by tab...) right click and drag - sets remembered position - when we will change plane of crossection      for example from tranverse to coonal this point will be also visible on new plane","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"all keyboard shortcuts will be activated on RELEASE of keys or by pressing enter while still pressing other; +,- and z keys acts also like enter ","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"shift + number - make mask associated with given number visible","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"ctrl + number -  make mask associated with given number invisible ","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"alt + number -  make mask associated with given number active for mouse interaction ","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"tab + number - sets the number that will be  used as an input to masks modified by mouse","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"when tab plus (and then no number) will be pressed it will increase stroke width","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"when tab minus (and then no number) will be pressed it will increase stroke width","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"shift + numberA + \"-\"(minus sign) +numberB  - display diffrence between masks associated with numberA and numberB - also it makes automaticall mask A and B invisible","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"ctrl + numberA + \"-\"(minus sign) +numberB  - stops displaying diffrence between masks associated with numberA and numberB - also it makes automaticall mask A and B visible","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"space + 1 or 2 or 3 - change the plane of view (transverse, coronal, sagittal)","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"ctrl + z - undo last action","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"tab +/- increase or decrease stroke width","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"F1 - will display wide window for bone Int32(1000),Int32(-1000)","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"F2 - will display window for soft tissues Int32(400),Int32(-200)","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"F3 - will display wide window for lung viewing  Int32(0),Int32(-1000)","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"F4,  F5 sets minimum (F4) and maximum (KEY_F5) value for display (with combination of + and minus signs - to increase or decrease given treshold) - ","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"In case of continuus colors it will clamp values - so all above max will be equaled to max ; and min if smallert than min","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"In case of main CT mask - it will controll min shown white and max shown black","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"In case of maks with single color associated we will step data so if data is outside the rande it will return 0 - so will not affect display F6 - controlls contribution  of given mask to the overall image - maximum value is 1 minimum 0 if we have 3 masks and all control contribution is set to 1 and all are visible their corresponding influence to pixel color is 33%  if plus is pressed it will increse contribution by 0.1   if minus is pressed it will decrease contribution by 0.1  ","category":"page"},{"location":"#Benchmark-PET/CT","page":"MedEye3d.jl","title":"Benchmark PET/CT","text":"","category":"section"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"For transparency I include Below code used to benchark  PET/CT data","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"window = Main.SegmentationDisplay.mainActor.actor.mainForDisplayObjects.window\nsyncActor = Main.SegmentationDisplay.mainActor\n\nusing GLFW,DataTypesBasic, ModernGL,Setfield\nusing BenchmarkTools\n\nBenchmarkTools.DEFAULT_PARAMETERS.samples = 100\nBenchmarkTools.DEFAULT_PARAMETERS.seconds =5000\nBenchmarkTools.DEFAULT_PARAMETERS.gcsample = true\n\n\nfunction toBenchmarkScroll(toSc) \n    NuclearMedEye.ReactToScroll.reactToScroll(toSc ,syncActor, false)\nend\n\n\nfunction toBenchmarkPaint(carts)\n    NuclearMedEye.ReactOnMouseClickAndDrag.reactToMouseDrag(MouseStruct(true,false, carts),syncActor )\nend\n\n\nfunction toBenchmarkPlaneTranslation(toScroll)\n    NuclearMedEye.ReactOnKeyboard.processKeysInfo(Option(toScroll),syncActor,KeyboardStruct(),false    )\n    OpenGLDisplayUtils.basicRender(syncActor.actor.mainForDisplayObjects.window)\n    glFinish()\nend\n\n\nfunction prepareRAndomCart(randInt) \n    return [CartesianIndex(12+randInt,13+randInt),CartesianIndex(12+randInt,15+randInt),CartesianIndex(12+randInt,18+randInt),CartesianIndex(2+randInt,10+randInt),CartesianIndex(2+randInt,14+randInt)]\nend\n\n#we want some integers but not 0\nsc = @benchmarkable toBenchmarkScroll(y) setup=(y = filter(it->it!=0, rand(-5:5,20))[1]  )\n\npaint =  @benchmarkable toBenchmarkPaint(y) setup=(y =  prepareRAndomCart(rand(1:40,1)[1]  ))  \n\ntranslations =  @benchmarkable toBenchmarkPlaneTranslation(y) setup=(y = setproperties(syncActor.actor.onScrollData.dataToScrollDims,  (dimensionToScroll=rand(1:3,2)[1])) )  \n\nusing BenchmarkPlots, StatsPlots\n# Define a parent BenchmarkGroup to contain our suite\n\nscrollingPETCT = run(sc)\nmouseInteractionPETCT = run(paint)\ntranslationsPETCT = run(translations)\n\n\nplot(scrollingPETCT)","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"If all will be ready you should see sth like on the image below","category":"page"},{"location":"#PURE-CT-image-exaple-,-MHD-file","page":"MedEye3d.jl","title":"PURE CT image exaple , MHD file","text":"","category":"section"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"Files  taken from https://sliver07.grand-challenge.org/ As previosly adjust path to your case","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"exampleLabel = \"C:\\\\GitHub\\\\JuliaMedPipe\\\\data\\\\liverPrimData\\\\training-labels\\\\label\\\\liver-seg002.mhd\"\nexampleCTscann = \"C:\\\\GitHub\\\\JuliaMedPipe\\\\data\\\\liverPrimData\\\\training-scans\\\\scan\\\\liver-orig002.mhd\"","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"Loading data","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"imagePureCT= getImageFromDirectory(exampleCTscann,true,false)\nimageMask= getImageFromDirectory(exampleLabel,true,false)\n\nctPixelsPure, ctSpacingPure = getPixelsAndSpacing(imagePureCT)\nmaskPixels, maskSpacing =getPixelsAndSpacing(imageMask)","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"We need to pass some metadata about image array size and voxel dimensions to enable proper display","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"datToScrollDimsB= NuclearMedEye.ForDisplayStructs.DataToScrollDims(imageSize=  size(ctPixelsPure) ,voxelSize=ctSpacingPure, dimensionToScroll = 3 );\n# example of texture specification used - we need to describe all arrays we want to display\nlistOfTexturesSpec = [\n    TextureSpec{UInt8}(\n        name = \"goldStandardLiver\",\n        numb= Int32(1),\n        color = RGB(1.0,0.0,0.0)\n        ,minAndMaxValue= Int8.([0,1])\n       ),\n    TextureSpec{UInt8}(\n        name = \"manualModif\",\n        numb= Int32(2),\n        color = RGB(0.0,1.0,0.0)\n        ,minAndMaxValue= UInt8.([0,1])\n        ,isEditable = true\n       ),\n\n       TextureSpec{Int16}(\n        name= \"CTIm\",\n        numb= Int32(3),\n        isMainImage = true,\n        minAndMaxValue= Int16.([0,100]))  \n ];","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"We need also to specify how big part of the screen should be occupied by the main image and how much by text fractionOfMainIm= Float32(0.8);","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"fractionOfMainIm= Float32(0.8);\n\"\"\"\nIf we want to display some text we need to pass it as a vector of SimpleLineTextStructs \n\"\"\"\nimport NuclearMedEye.DisplayWords.textLinesFromStrings\n\nmainLines= textLinesFromStrings([\"main Line1\", \"main Line 2\"]);\nsupplLines=map(x->  textLinesFromStrings([\"sub  Line 1 in $(x)\", \"sub  Line 2 in $(x)\"]), 1:size(ctPixelsPure)[3] );\n\n\"\"\"\nIf we want to pass 3 dimensional array of scrollable data\"\"\"\nimport NuclearMedEye.StructsManag.getThreeDims\n\ntupleVect = [(\"goldStandardLiver\",maskPixels) ,(\"CTIm\",ctPixelsPure),(\"manualModif\",zeros(UInt8,size(ctPixelsPure)) ) ]\nslicesDat= getThreeDims(tupleVect )\n\n\"\"\"\nHolds data necessary to display scrollable data\n\"\"\"\nmainScrollDat = FullScrollableDat(dataToScrollDims =datToScrollDimsB\n                                 ,dimensionToScroll=1 # what is the dimension of plane we will look into at the beginning for example transverse, coronal ...\n                                 ,dataToScroll= slicesDat\n                                 ,mainTextToDisp= mainLines\n                                 ,sliceTextToDisp=supplLines );\n\n","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"This function prepares all for display; 1000 in the end is responsible for setting window width for more look into SegmentationDisplay.coordinateDisplay","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"SegmentationDisplay.coordinateDisplay(listOfTexturesSpec ,fractionOfMainIm ,datToScrollDimsB ,1000);","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"As all is ready we can finally display image ","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"Main.SegmentationDisplay.passDataForScrolling(mainScrollDat);\n","category":"page"},{"location":"#Next-part-of-benchmark-for-pure-CT","page":"MedEye3d.jl","title":"Next part of benchmark for pure CT","text":"","category":"section"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"#we want some integers but not 0\nscPureCt = @benchmarkable toBenchmarkScroll(y) setup=(y = filter(it->it!=0, rand(-5:5,20))[1]  )\n\npaintPureCt =  @benchmarkable toBenchmarkPaint(y) setup=(y =  prepareRAndomCart(rand(1:40,1)[1]  ))  \n\ntranslationsPureCt =  @benchmarkable toBenchmarkPlaneTranslation(y) setup=(y = setproperties(syncActor.actor.onScrollData.dataToScrollDims,  (dimensionToScroll=rand(1:3,2)[1])) )  \n\nusing BenchmarkPlots, StatsPlots\n\n\n\nscB = @benchmarkable toBenchmarkScroll(y) setup=(y = filter(it->it!=0, rand(-5:5,20))[1]  )\n\npaintB =  @benchmarkable toBenchmarkPaint(y) setup=(y =  prepareRAndomCart(rand(1:40,1)[1]  ))  \n\ntranslationsB =  @benchmarkable toBenchmarkPlaneTranslation(y) setup=(y = setproperties(syncActor.actor.onScrollData.dataToScrollDims,  (dimensionToScroll=rand(1:3,2)[1])) )  \n\nusing BenchmarkPlots, StatsPlots\n# Define a parent BenchmarkGroup to contain our suite\n\nscrollingPureCT = run(scB)\nmouseInteractionPureCT = run(paintB)\ntranslationsPureCT = run(translationsB)","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"When all will be ok and you will scroll up  you should see sth like below","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"(Image: soft_liv)","category":"page"},{"location":"","page":"MedEye3d.jl","title":"MedEye3d.jl","text":"Modules = [MedEye3d\n    ,MedEye3d.SegmentationDisplay\n    ,MedEye3d.ReactingToInput\n    ,MedEye3d.ReactOnKeyboard\n    ,MedEye3d.ReactOnMouseClickAndDrag\n    ,MedEye3d.ReactToScroll\n    ,MedEye3d.PrepareWindow\n    ,MedEye3d.TextureManag\n    ,MedEye3d.DisplayWords\n    ,MedEye3d.Uniforms\n    ,MedEye3d.ShadersAndVerticiesForText\n    ,MedEye3d.ShadersAndVerticies\n    ,MedEye3d.OpenGLDisplayUtils\n    ,MedEye3d.CustomFragShad\n    ,MedEye3d.PrepareWindowHelpers\n    ,MedEye3d.StructsManag\n    ,MedEye3d.ForDisplayStructs\n    ,MedEye3d.DataStructs\n    ,MedEye3d.BasicStructs\n    ,MedEye3d.ModernGlUtil\n    ,MedEye3d.MaskDiffrence\n    ,MedEye3d.KeyboardVisibility\n    ,MedEye3d.OtherKeyboardActions\n    ,MedEye3d.WindowControll\n    ,MedEye3d.ChangePlane]\nOrder   = [:module,:function, :type,:constant]","category":"page"},{"location":"#MedEye3d.SegmentationDisplay","page":"MedEye3d.jl","title":"MedEye3d.SegmentationDisplay","text":"Main module controlling displaying segmentations image and data\n\n\n\n\n\n","category":"module"},{"location":"#MedEye3d.SegmentationDisplay.cleanUp-Tuple{}","page":"MedEye3d.jl","title":"MedEye3d.SegmentationDisplay.cleanUp","text":"In order to properly close displayer we need to :  remove buffers that wer use   remove shaders   remove all textures  unsubscibe all of the subscriptions to the mainActor  finalize main actor and reinstantiate it  close GLFW window\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.SegmentationDisplay.coordinateDisplay","page":"MedEye3d.jl","title":"MedEye3d.SegmentationDisplay.coordinateDisplay","text":"coordinating displaying - sets needed constants that are storeds in  forDisplayConstants; and configures interactions from GLFW events listOfTextSpecs - holds required data needed to initialize textures keeps also references to needed ..Uniforms etc. windowWidth::Int,windowHeight::Int - GLFW window dimensions fractionOfMainIm - how much of width should be taken by the main image heightToWithRatio - needed for proper display of main texture - so it would not be stretched ...\n\n\n\n\n\n","category":"function"},{"location":"#MedEye3d.SegmentationDisplay.passDataForScrolling-Tuple{MedEye3d.DataStructs.FullScrollableDat}","page":"MedEye3d.jl","title":"MedEye3d.SegmentationDisplay.passDataForScrolling","text":"is used to pass into the actor data that will be used for scrolling onScrollData - struct holding between others list of tuples where first is the name of the texture that we provided and second is associated data (3 dimensional array of appropriate type)\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.SegmentationDisplay.prepareForDispStruct","page":"MedEye3d.jl","title":"MedEye3d.SegmentationDisplay.prepareForDispStruct","text":"Preparing ForWordsDispStruct that will be needed for proper displaying of texts     numberOfActiveTextUnits - number of textures already used - so we we will know what is still free      fragmentshaderwords - reference to fragment shader used to display text     vbowords - vertex buffer object used to display words     shaderprogram_words - shader program associated with displaying text     widthh, heightt - size of the texture - the bigger the higher resolution, but higher computation cost\n\nreturn prepared for displayStruct    \n\n\n\n\n\n","category":"function"},{"location":"#MedEye3d.SegmentationDisplay.registerInteractions-Tuple{}","page":"MedEye3d.jl","title":"MedEye3d.SegmentationDisplay.registerInteractions","text":"is using the actor that is instantiated in this module and connects it to GLFW context by invoking appropriate registering functions and passing to it to the main Actor controlling input\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.SegmentationDisplay.updateSingleImagesDisplayed-Tuple{MedEye3d.DataStructs.SingleSliceDat}","page":"MedEye3d.jl","title":"MedEye3d.SegmentationDisplay.updateSingleImagesDisplayed","text":"enables updating just a single slice that is displayed - do not change what will happen after scrolling one need to pass data to actor in  listOfDataAndImageNames - struct holding  tuples where first entry in tuple is name of texture given in the setup and second is 2 dimensional aray of appropriate type with image data sliceNumber - the number to which we set slice in order to later start scrolling the scroll data from this point\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ReactingToInput.setUpCalcDimsStruct-Tuple{MedEye3d.DataStructs.CalcDimsStruct, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}}","page":"MedEye3d.jl","title":"MedEye3d.ReactingToInput.setUpCalcDimsStruct","text":"add data needed for proper calculations of mouse, verticies positions ... etc\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ReactingToInput.setUpForScrollData-Tuple{MedEye3d.DataStructs.FullScrollableDat, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}}","page":"MedEye3d.jl","title":"MedEye3d.ReactingToInput.setUpForScrollData","text":"adding the data about 3 dimensional arrays that will be source of data used for scrolling behaviour onScroll Data - list of tuples where first is the name of the texture that we provided and second is associated data (3 dimensional array of appropriate type)\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ReactingToInput.setUpMainDisplay-Tuple{MedEye3d.ForDisplayStructs.forDisplayObjects, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}}","page":"MedEye3d.jl","title":"MedEye3d.ReactingToInput.setUpMainDisplay","text":"adding the data into about openGL and GLFW context to enable proper display of main image and masks\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ReactingToInput.setUpWordsDisplay-Tuple{MedEye3d.ForDisplayStructs.ForWordsDispStruct, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}}","page":"MedEye3d.jl","title":"MedEye3d.ReactingToInput.setUpWordsDisplay","text":"adding the data needed for text display; also activates appropriate quad for the display     it also configures texture that is build for text display\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ReactingToInput.setUpvalueForMasToSet-Tuple{MedEye3d.DataStructs.valueForMasToSetStruct, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}}","page":"MedEye3d.jl","title":"MedEye3d.ReactingToInput.setUpvalueForMasToSet","text":"sets value we are setting to the  active mask vie mause interaction, in case mask is modifiable \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ReactingToInput.subscribeGLFWtoActor-Tuple{Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}}","page":"MedEye3d.jl","title":"MedEye3d.ReactingToInput.subscribeGLFWtoActor","text":"when GLFW context is ready we need to use this  function in order to register GLFW events to Rocket actor - we use subscription for this     actor - Roctet actor that holds objects needed for display like window etc...       return list of subscriptions so if we will need it we can unsubscribe\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ReactingToInput.updateSingleImagesDisplayedSetUp-Tuple{MedEye3d.DataStructs.SingleSliceDat, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}}","page":"MedEye3d.jl","title":"MedEye3d.ReactingToInput.updateSingleImagesDisplayedSetUp","text":"enables updating just a single slice that is displayed - do not change what will happen after scrolling one need to pass data to actor in  struct that holds tuple where first entry is -vector of tuples whee first entry in tuple is name of texture given in the setup and second is 2 dimensional aray of appropriate type with image data\n\nInt - second is Int64 - that is marking the screen number to which we wan to set the actor state\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ReactOnKeyboard.findTextureBasedOnNumb-Tuple{Vector{MedEye3d.ForDisplayStructs.TextureSpec}, Int32, Dictionaries.Dictionary{Int32, Int64}}","page":"MedEye3d.jl","title":"MedEye3d.ReactOnKeyboard.findTextureBasedOnNumb","text":"given number from keyboard input it return array With texture that holds the texture specification we are looking for  listOfTextSpecifications - list with all registered Texture specifications numb - string that may represent number - if it does not function will return empty option return Option - either Texture specification or empty Option \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ReactOnKeyboard.parseString-Tuple{Vector{String}, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}, MedEye3d.ForDisplayStructs.KeyboardStruct}","page":"MedEye3d.jl","title":"MedEye3d.ReactOnKeyboard.parseString","text":"Given string it parser it to given object on the basis of with and multiple dispatch futher actions will be done it checks each character weather is numeric - gets substring of all numeric characters and parses it into integer listOfTextSpecifications - list with all registered Texture specifications return option of diffrent type depending on input\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ReactOnKeyboard.reactToKeyboard-Tuple{MedEye3d.ForDisplayStructs.KeyboardStruct, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}}","page":"MedEye3d.jl","title":"MedEye3d.ReactOnKeyboard.reactToKeyboard","text":"Given keyInfo struct wit information about pressed keys it can process them to make some actions  - generally activating keyboard shortcuts shift + number - make mask associated with given number visible ctrl + number -  make mask associated with given number invisible  alt + number -  make mask associated with given number active for mouse interaction  tab + number - sets the number that will be  used as an input to masks modified by mouse shift + numberA + \"m\" +numberB  - display diffrence between masks associated with numberA and numberB - also it makes automaticall mask A and B invisible ctrl + numberA + \"m\" +numberB  - stops displaying diffrence between masks associated with numberA and numberB - also it makes automaticall mask A and B visible space + 1 or 2 or 3 - change the plane of view (transverse, coronal, sagittal) ctrl + z - undo last action tab +/- increase or decrease stroke width F1, F2 ... - switch between defined window display characteristics - like min shown white and mx shown black ...\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ReactOnKeyboard.registerKeyboardFunctions-Tuple{GLFW.Window, Base.Threads.Atomic{Bool}}","page":"MedEye3d.jl","title":"MedEye3d.ReactOnKeyboard.registerKeyboardFunctions","text":"registering functions to the GLFW window - GLFW window with Visualization stopListening - atomic boolean enabling unlocking GLFW context\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ReactOnKeyboard.shouldBeExecuted-Tuple{MedEye3d.ForDisplayStructs.KeyboardStruct, Int64}","page":"MedEye3d.jl","title":"MedEye3d.ReactOnKeyboard.shouldBeExecuted","text":"return true in case the combination of keys should invoke some action\n\n\n\n\n\n","category":"method"},{"location":"#Rocket.on_subscribe!-Tuple{MedEye3d.ForDisplayStructs.KeyboardCallbackSubscribable, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}}","page":"MedEye3d.jl","title":"Rocket.on_subscribe!","text":"will \"tell\" what functions should be invoked in order to process keyboard input \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ForDisplayStructs.KeyboardCallbackSubscribable-Tuple{String, GLFW.Action}","page":"MedEye3d.jl","title":"MedEye3d.ForDisplayStructs.KeyboardCallbackSubscribable","text":"given pressed keys lik 1-9 and all letters resulting key is encoded as string and will be passed here handler object responsible for capturing action  str - name of key lik 1,5 f,.j ... but not ctrl shift etc action - for example key press or release scancode - if key do not have short name like ctrl ... it has scancode\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ReactOnMouseClickAndDrag","page":"MedEye3d.jl","title":"MedEye3d.ReactOnMouseClickAndDrag","text":"module  code adapted from https://discourse.julialang.org/t/custom-subject-in-rocket-jl-for-mouse-events-from-glfw/65133/3 it is design to help processing data from      -GLFW.SetCursorPosCallback(window, (, x, y) -> println(\"cursor: x, y\")) and  for example : cursor: 29.0, 469.0  types   Float64  Float64        -GLFW.SetMouseButtonCallback(window, (, button, action, mods) -> println(\"button action\"))  for example types MOUSEBUTTON1 PRESS   GLFW.MouseButton  GLFW.Action  The main function is to mark the interaction of the mouse to be saved in appropriate mask and be rendered onto the screen so we modify the data that is the basis of the mouse interaction mask  and we pass the data on so appropriate part of the texture would be modified to be displayed on screen\n\n\n\n\n\n","category":"module"},{"location":"#MedEye3d.ReactOnMouseClickAndDrag.addStrokeWidth-Tuple{CartesianIndex{2}, Int64}","page":"MedEye3d.jl","title":"MedEye3d.ReactOnMouseClickAndDrag.addStrokeWidth","text":"adding the width to the stroke so we will be able to controll how thicly we are painting ...\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ReactOnMouseClickAndDrag.getNewX-Tuple{Int64, MedEye3d.DataStructs.CalcDimsStruct}","page":"MedEye3d.jl","title":"MedEye3d.ReactOnMouseClickAndDrag.getNewX","text":"helper function for translateMouseToTexture\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ReactOnMouseClickAndDrag.getNewY-Tuple{Int64, MedEye3d.DataStructs.CalcDimsStruct}","page":"MedEye3d.jl","title":"MedEye3d.ReactOnMouseClickAndDrag.getNewY","text":"helper function for translateMouseToTexture\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ReactOnMouseClickAndDrag.reactToMouseDrag-Tuple{MedEye3d.ForDisplayStructs.MouseStruct, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}}","page":"MedEye3d.jl","title":"MedEye3d.ReactOnMouseClickAndDrag.reactToMouseDrag","text":"we use mouse coordinate to modify the texture that is currently active for modifications      - we take information about texture currently active for modifications from variables stored in actor     from texture specification we take also its id and its properties ...\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ReactOnMouseClickAndDrag.registerMouseClickFunctions-Tuple{GLFW.Window, Base.Threads.Atomic{Bool}, MedEye3d.DataStructs.CalcDimsStruct, Base.Threads.Atomic{Bool}}","page":"MedEye3d.jl","title":"MedEye3d.ReactOnMouseClickAndDrag.registerMouseClickFunctions","text":"we pass coordinate of cursor only when isLeftButtonDown is true and we make it true  if left button is presed down - we make it true if the left button is pressed over image and false if mouse get out of the window or we get information about button release imageWidth adn imageHeight are the dimensions of textures that we use to display \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ReactOnMouseClickAndDrag.translateMouseToTexture-Tuple{Int32, Vector{CartesianIndex{2}}, MedEye3d.DataStructs.CalcDimsStruct}","page":"MedEye3d.jl","title":"MedEye3d.ReactOnMouseClickAndDrag.translateMouseToTexture","text":"given list of cartesian coordinates and some window/ image characteristics - it translates mouse positions to cartesian coordinates of the texture strokeWidth - the property connected to the texture marking how thick should be the brush mouseCoords - list of coordinates of mouse positions while left button remains pressed calcDims - set of values usefull for calculating mouse position return vector of translated cartesian coordinates\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ForDisplayStructs.MouseCallbackSubscribable-Tuple{Any, Float64, Float64}","page":"MedEye3d.jl","title":"MedEye3d.ForDisplayStructs.MouseCallbackSubscribable","text":"we define how handler should act on the subject - observable so it will pass event onto subject - here we have 2 events that we want to be ready for - mouse button press example of possible inputs that we would be intrested in  for example : cursor: 29.0, 469.0  types   Float64  Float64    for example  MOUSEBUTTON1 PRESS    types GLFW.MouseButton  GLFW.Action               MOUSEBUTTON1 RELEASE  types GLFW.MouseButton  GLFW.Action  We get two overloads so we will be able to respond with single handler to both mouse click and mouse position Enum GLFW.Action: RELEASE = 0 PRESS = 1 REPEAT = 2 Enum GLFW.MouseButton: MOUSEBUTTON1 = 0 MOUSEBUTTON2 = 1\n\nexperiments show that max x,y in window is both 600 if window width and height is 600   so in order to specify weather we are over aour quad we need to know how big is primary quad -   defaoul it is occupying 100% of y axis and first left 80% of x axis   hence we can calculate max height to equal the height of the window \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ReactToScroll","page":"MedEye3d.jl","title":"MedEye3d.ReactToScroll","text":"module that holds functions needed to  react to scrolling Generally first we need to pass the GLFW callback to the Rocket obeservable  code adapted from https://discourse.julialang.org/t/custom-subject-in-rocket-jl-for-mouse-events-from-glfw/65133/3\n\n\n\n\n\n","category":"module"},{"location":"#MedEye3d.ReactToScroll.reactToScroll","page":"MedEye3d.jl","title":"MedEye3d.ReactToScroll.reactToScroll","text":"in case of the scroll p true will be send in case of down - false in response to it it sets new screen int variable and changes displayed screen toBeSavedForBack - just marks weather we wat to save the info how to undo latest action\n\nfalse if we invoke it from undoing \n\n\n\n\n\n","category":"function"},{"location":"#MedEye3d.ReactToScroll.registerMouseScrollFunctions-Tuple{GLFW.Window, Base.Threads.Atomic{Bool}, Base.Threads.Atomic{Bool}}","page":"MedEye3d.jl","title":"MedEye3d.ReactToScroll.registerMouseScrollFunctions","text":"uploading data to given texture; of given types associated returns subscription in order to enable unsubscribing in the end  window - GLFW window  stopListening - atomic boolean able to stop the event listening cycle return scrollback - that holds boolean subject (observable) to which we can react by subscribing appropriate actor\n\n\n\n\n\n","category":"method"},{"location":"#Rocket.on_subscribe!-Tuple{MedEye3d.ForDisplayStructs.ScrollCallbackSubscribable, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}}","page":"MedEye3d.jl","title":"Rocket.on_subscribe!","text":"configuting Rocket on Subscribe so we get custom handler of input as we see we still need to define actor\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ForDisplayStructs.ScrollCallbackSubscribable-Tuple{Any, Any, Any}","page":"MedEye3d.jl","title":"MedEye3d.ForDisplayStructs.ScrollCallbackSubscribable","text":"we define how handler should act on the subject - observable so it will pass event onto subject If we will scroll fast number will change much  and we will skip some slices\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.PrepareWindow.createAndInitShaderProgram-Tuple{UInt32, Vector{MedEye3d.ForDisplayStructs.TextureSpec}, MedEye3d.ForDisplayStructs.TextureSpec, MedEye3d.ForDisplayStructs.TextureSpec, String}","page":"MedEye3d.jl","title":"MedEye3d.PrepareWindow.createAndInitShaderProgram","text":"On the basis of information from listOfTexturesToCreate it creates specialized shader program\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.PrepareWindow.displayAll-Tuple{Vector{MedEye3d.ForDisplayStructs.TextureSpec}, MedEye3d.DataStructs.CalcDimsStruct}","page":"MedEye3d.jl","title":"MedEye3d.PrepareWindow.displayAll","text":"preparing all for displaying the images and responding to mouse and keyboard input \tlistOfTexturesToCreate- list of texture specifications needed to for example create optimal shader \tcalcDimsStruct - holds important data about verticies, textures dimensions etc.\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.TextureManag","page":"MedEye3d.jl","title":"MedEye3d.TextureManag","text":"stores functions needed to create bind and update OpenGl textues \n\n\n\n\n\n","category":"module"},{"location":"#MedEye3d.TextureManag.activateTextures-Tuple{Vector{MedEye3d.ForDisplayStructs.TextureSpec}}","page":"MedEye3d.jl","title":"MedEye3d.TextureManag.activateTextures","text":"activating textures that were already initialized in order to be able to use them with diffrent shader program  shader_program- regference to OpenGL program so we will be able to activate  textures listOfTextSpecs - list of TextureSpec structs that  holds data needed to bind textures to shader program (Hovewer this new shader program have to keep the same ..Uniforms) return unmodified textures\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.TextureManag.addTextToTexture-Tuple{MedEye3d.ForDisplayStructs.ForWordsDispStruct, Vector{MedEye3d.DataStructs.SimpleLineTextStruct}, MedEye3d.DataStructs.CalcDimsStruct}","page":"MedEye3d.jl","title":"MedEye3d.TextureManag.addTextToTexture","text":"Given  vector of SimpleLineTextStructs it will return matrix of data that will be used  to display text  lines - data about text to be displayed calcDimStruct - struct holding important data about size of textures etc. wordsDispObj - object wit needed constants to display text\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.TextureManag.assignUniformsAndTypesToMasks-Tuple{Vector{MedEye3d.ForDisplayStructs.TextureSpec}, UInt32, MedEye3d.DataStructs.WindowControlStruct}","page":"MedEye3d.jl","title":"MedEye3d.TextureManag.assignUniformsAndTypesToMasks","text":"on the basis of the type supplied in texture characteristic it supplies given set of ..Uniforms to it  It would also assign proper openGl types to given julia data type, and pass data from texture specification to opengl context textSpecs - list of texture specificaton that we want to enrich by adding information about ..Uniforms return list of texture specifications enriched by information about ..Uniforms \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.TextureManag.createTexture-Union{Tuple{juliaDataTyp}, Tuple{Type{juliaDataTyp}, Int32, Int32}, Tuple{Type{juliaDataTyp}, Int32, Int32, UInt32}, Tuple{Type{juliaDataTyp}, Int32, Int32, UInt32, Any}} where juliaDataTyp","page":"MedEye3d.jl","title":"MedEye3d.TextureManag.createTexture","text":"creating texture that is storing values like integer, uint, float values that are representing  main image or  mask data and which will be used by a shader to draw appropriate colors juliaDataType- data type defined as a Julia datatype of data we are dealing with  width,height - dimensions of the texture that we need GL_RType,OpGlType - Open Gl types needed to properly specify the  texture they need to be compatible with juliaDataType\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.TextureManag.getProperGL_TEXTURE-Tuple{Int64}","page":"MedEye3d.jl","title":"MedEye3d.TextureManag.getProperGL_TEXTURE","text":"associates GL_TEXTURE UInt32 to given index \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.TextureManag.initializeTextures-Tuple{Vector{MedEye3d.ForDisplayStructs.TextureSpec}, MedEye3d.DataStructs.CalcDimsStruct}","page":"MedEye3d.jl","title":"MedEye3d.TextureManag.initializeTextures","text":"initializing textures  - so we basically execute specification for configuration and bind all to OpenGL context listOfTextSpecs - list of TextureSpec structs that  holds data needed to  calcDimStruct - struct holding necessery data about taxture dimensions, quad propertiess etc.\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.TextureManag.setProperOpenGlTypes-Tuple{MedEye3d.ForDisplayStructs.TextureSpec}","page":"MedEye3d.jl","title":"MedEye3d.TextureManag.setProperOpenGlTypes","text":"On the basis of the type associated to texture we set proper open Gl types associated  based on https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml and https://www.khronos.org/opengl/wiki/OpenGL_Type\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.TextureManag.setuniforms-Tuple{MedEye3d.ForDisplayStructs.TextureSpec, UInt32}","page":"MedEye3d.jl","title":"MedEye3d.TextureManag.setuniforms","text":"helper for assign..UniformsToMasks  On the basis of the name of the Texture it will assign the informs referencs to it \n\n..Uniforms for main image will be set separately\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.TextureManag.updateImagesDisplayed-Tuple{MedEye3d.DataStructs.SingleSliceDat, MedEye3d.ForDisplayStructs.forDisplayObjects, MedEye3d.ForDisplayStructs.ForWordsDispStruct, MedEye3d.DataStructs.CalcDimsStruct, MedEye3d.DataStructs.valueForMasToSetStruct}","page":"MedEye3d.jl","title":"MedEye3d.TextureManag.updateImagesDisplayed","text":"coordinating updating all of the images, masks...  singleSliceDat - holds data we want to use for update forDisplayObjects - stores all needed constants that holds reference to GLFW and OpenGL\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.TextureManag.updateTexture-Union{Tuple{Tt}, Tuple{Type{Tt}, AbstractArray, MedEye3d.ForDisplayStructs.TextureSpec, Int64, Int64, Int32, Int32}} where Tt","page":"MedEye3d.jl","title":"MedEye3d.TextureManag.updateTexture","text":"uploading data to given texture; of given types associated - specified in TextureSpec if we want to update only part of the texture we need to specify  offset and size of texture we use  Just for reference openGL function definition     void glTextureSubImage2D(\t         GLuint texture,          GLint level,          GLint xoffset,          GLint yoffset,          GLsizei width,          GLsizei height,          GLenum format,          GLenum type,          const void *pixels);  \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.DisplayWords","page":"MedEye3d.jl","title":"MedEye3d.DisplayWords","text":"Module controlling displaying of the text associated with the segmentation \n\neither text releted to all slices or just a single one currently displayed or both\n\n\n\n\n\n","category":"module"},{"location":"#MedEye3d.DisplayWords.activateForTextDisp-Tuple{UInt32, Base.RefValue{UInt32}, MedEye3d.DataStructs.CalcDimsStruct}","page":"MedEye3d.jl","title":"MedEye3d.DisplayWords.activateForTextDisp","text":"In order to be able to display texture with text we need to activate main shader program and vbo     shaderprogram- reference to shader program     fragmentshader_words - reference to shader associated with text displaying     calcDim - holds necessery constants holding for example window dimensions, texture sizes etc.\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.DisplayWords.bindAndActivateForText-Tuple{UInt32, UInt32, UInt32, Base.RefValue{UInt32}, MedEye3d.DataStructs.CalcDimsStruct}","page":"MedEye3d.jl","title":"MedEye3d.DisplayWords.bindAndActivateForText","text":"First We need to bind fragment shader created to deal with text and supply the vertex shader with data for quad where this text needs to be displayed     shader_program- reference to shader program this function is intended to be invoked only once\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.DisplayWords.createTextureForWords","page":"MedEye3d.jl","title":"MedEye3d.DisplayWords.createTextureForWords","text":"Creates and initialize texture that will be used for displaying text    !!!! important we need to first bind shader program for text display before we will  invoke this function     numberOfActiveTextUnits - number of textures already used - so we we will know what is still free      widthh, heightt - size of the texture - the bigger the higher resolution, but higher computation cost     actTextrureNumb -proper OpenGL active texture      return fully initialized texture; also it assigne texture to appropriate sampler\n\n\n\n\n\n","category":"function"},{"location":"#MedEye3d.DisplayWords.getTextForCurrentSlice-Tuple{MedEye3d.DataStructs.FullScrollableDat, Int32}","page":"MedEye3d.jl","title":"MedEye3d.DisplayWords.getTextForCurrentSlice","text":"we need to check wether scrolling dat contains some text that can be used for this particular slice display if not we will return only mainTextToDisp\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.DisplayWords.reactivateMainObj-Tuple{UInt32, UInt32, MedEye3d.DataStructs.CalcDimsStruct}","page":"MedEye3d.jl","title":"MedEye3d.DisplayWords.reactivateMainObj","text":"Finally in order to enable later proper display of the images we need to reactivate main quad and shaders shaderprogram- reference to shader program fragmentshader_main- reference to shader associated with main images\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.DisplayWords.renderSingleLineOfText-Tuple{MedEye3d.DataStructs.SimpleLineTextStruct, Int32, FreeTypeAbstraction.FTFont}","page":"MedEye3d.jl","title":"MedEye3d.DisplayWords.renderSingleLineOfText","text":"Given  single SimpleLineTextStruct it will return matrix of data that will be used  by addTextToTexture function     to display text      texLine - source od data     textureWidth - available width for a line     fontFace - font we use\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.DisplayWords.textLinesFromStrings-Tuple{Vector{String}}","page":"MedEye3d.jl","title":"MedEye3d.DisplayWords.textLinesFromStrings","text":"utility function that enables creating list of  text line structs from list of strings\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.Uniforms","page":"MedEye3d.jl","title":"MedEye3d.Uniforms","text":"managing  uniform values - global values in shaders\n\n\n\n\n\n","category":"module"},{"location":"#MedEye3d.Uniforms.changeTextureContribution-Tuple{MedEye3d.ForDisplayStructs.TextureSpec, Float32}","page":"MedEye3d.jl","title":"MedEye3d.Uniforms.changeTextureContribution","text":"controlls contribution  of given mask to the overall image - maximum value is 1 minimum 0 if we have 3 masks and all control contribution is set to 1 and all are visible their corresponding influence to pixel color is 33%       if plus is pressed it will increse contribution by 0.1         if minus is pressed it will decrease contribution by 0.1  it also modifies given TextureSpec           change - how should the texture spec be modified\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.Uniforms.coontrolMinMaxUniformVals-Tuple{MedEye3d.ForDisplayStructs.TextureSpec}","page":"MedEye3d.jl","title":"MedEye3d.Uniforms.coontrolMinMaxUniformVals","text":"sets minimum and maximum value for display -      in case of continuus colors it will clamp values - so all above max will be equaled to max ; and min if smallert than min     in case of main CT mask - it will controll min shown white and max shown black     in case of maks with single color associated we will step data so if data is outside the rande it will return 0 - so will not affect display\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.Uniforms.setCTWindow-Tuple{Int32, Int32, MedEye3d.ForDisplayStructs.MainImageUniforms}","page":"MedEye3d.jl","title":"MedEye3d.Uniforms.setCTWindow","text":"function cotrolling the window  for displaying CT scan  - min white and max maxshownblack     uniformsStore - instantiated object holding references to uniforms controlling displayed window\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.Uniforms.setMaskColor-Tuple{ColorTypes.RGB, MedEye3d.ForDisplayStructs.MaskTextureUniforms}","page":"MedEye3d.jl","title":"MedEye3d.Uniforms.setMaskColor","text":"sets color of the mask\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.Uniforms.setTextureVisibility-Tuple{Bool, MedEye3d.ForDisplayStructs.TextureUniforms}","page":"MedEye3d.jl","title":"MedEye3d.Uniforms.setTextureVisibility","text":"sets visibility of the texture\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ShadersAndVerticiesForText.createFragmentShader-Tuple{String}","page":"MedEye3d.jl","title":"MedEye3d.ShadersAndVerticiesForText.createFragmentShader","text":"creating fragment Shader  so controlling colors and textures   gslString so version of GSLS we are using currently\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ShadersAndVerticiesForText.createVertexShader-Tuple{String}","page":"MedEye3d.jl","title":"MedEye3d.ShadersAndVerticiesForText.createVertexShader","text":"creating VertexShader  so controlling structures like verticies, quads gslString so version of GSLS we are using currently\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ShadersAndVerticiesForText.getWordsVerticies-Tuple{Float32}","page":"MedEye3d.jl","title":"MedEye3d.ShadersAndVerticiesForText.getWordsVerticies","text":"generetes verticies for quad used for displaying text\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ShadersAndVerticies.createFragmentShader-Tuple{String, Vector{MedEye3d.ForDisplayStructs.TextureSpec}, MedEye3d.ForDisplayStructs.TextureSpec, MedEye3d.ForDisplayStructs.TextureSpec}","page":"MedEye3d.jl","title":"MedEye3d.ShadersAndVerticies.createFragmentShader","text":"creating fragment Shader  so controlling colors and textures   gslString so version of GSLS we are using currently\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ShadersAndVerticies.createVertexShader-Tuple{String}","page":"MedEye3d.jl","title":"MedEye3d.ShadersAndVerticies.createVertexShader","text":"creating VertexShader  so controlling structures like verticies, quads gslString so version of GSLS we are using currently\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ShadersAndVerticies.getShaderFileText-Tuple{String}","page":"MedEye3d.jl","title":"MedEye3d.ShadersAndVerticies.getShaderFileText","text":"loading the shader from file- so we have better experience writing shader in separate file (can be used if we do not use Custom frag shader)\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.OpenGLDisplayUtils.basicRender-Tuple{Any}","page":"MedEye3d.jl","title":"MedEye3d.OpenGLDisplayUtils.basicRender","text":"As most functions will deal with just addind the quad to the screen  and swapping buffers\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.CustomFragShad","page":"MedEye3d.jl","title":"MedEye3d.CustomFragShad","text":"functions that will enable creation of long String that will be the code for custom fragment shader that will be suited for defined textures\n\n\n\n\n\n","category":"module"},{"location":"#MedEye3d.CustomFragShad.addColorUniform-Tuple{MedEye3d.ForDisplayStructs.TextureSpec}","page":"MedEye3d.jl","title":"MedEye3d.CustomFragShad.addColorUniform","text":"Adding ..Uniforms resopnsible for colors associated with given mask \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.CustomFragShad.addMainTextureStrings-Tuple{MedEye3d.ForDisplayStructs.TextureSpec}","page":"MedEye3d.jl","title":"MedEye3d.CustomFragShad.addMainTextureStrings","text":"managing main texture and on the basis of the type  we will initialize diffrent variables mainTexture - specification of a texture related to main image\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.CustomFragShad.addMasksStrings-Tuple{MedEye3d.ForDisplayStructs.TextureSpec}","page":"MedEye3d.jl","title":"MedEye3d.CustomFragShad.addMasksStrings","text":"Adding string necessary for managing ..Uniforms of masks textures\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.CustomFragShad.addSamplerStr-Tuple{MedEye3d.ForDisplayStructs.TextureSpec, String}","page":"MedEye3d.jl","title":"MedEye3d.CustomFragShad.addSamplerStr","text":"setting string representing sampler depending on type\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.CustomFragShad.addTypeStr-Tuple{MedEye3d.ForDisplayStructs.TextureSpec}","page":"MedEye3d.jl","title":"MedEye3d.CustomFragShad.addTypeStr","text":"giving variable name associated with given type\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.CustomFragShad.addUniformsForNuclearAndSubtr-Tuple{}","page":"MedEye3d.jl","title":"MedEye3d.CustomFragShad.addUniformsForNuclearAndSubtr","text":"Add ..Uniforms necessary for operation of mask subtraction and  for proper display of nuclear medicine masks\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.CustomFragShad.addWindowingFunc-Tuple{MedEye3d.ForDisplayStructs.TextureSpec}","page":"MedEye3d.jl","title":"MedEye3d.CustomFragShad.addWindowingFunc","text":"giving string representing main function defining how windowing of main image should be performed\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.CustomFragShad.chooseColorFonuction-Tuple{MedEye3d.ForDisplayStructs.TextureSpec}","page":"MedEye3d.jl","title":"MedEye3d.CustomFragShad.chooseColorFonuction","text":"on the basis of texture type gives proper function controlling color of the mask \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.CustomFragShad.createCustomFramgentShader-Tuple{Vector{MedEye3d.ForDisplayStructs.TextureSpec}, MedEye3d.ForDisplayStructs.TextureSpec, MedEye3d.ForDisplayStructs.TextureSpec}","page":"MedEye3d.jl","title":"MedEye3d.CustomFragShad.createCustomFramgentShader","text":"We will in couple steps create code for fragment shader that will be based on the texture definitions we gave  listOfTexturesToCreate - list of textures on the basis of which we will create custom fragment shader code maskToSubtrastFrom,maskWeAreSubtracting - texture specifications used in order to generate code needed to diplay diffrence between those two masks - every time we want diffrent diffrence we will need to recreate shader invoking this function\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.CustomFragShad.divideTexteuresToMainAndRest-Tuple{Vector{MedEye3d.ForDisplayStructs.TextureSpec}}","page":"MedEye3d.jl","title":"MedEye3d.CustomFragShad.divideTexteuresToMainAndRest","text":"We divide textures into main image texture and the rest listOfTexturesToCreate - list of textures on the basis of which we will create custom fragment shader code returns tuple where fist entr is the main image texture specification and second is rest of textures\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.CustomFragShad.getMasksSubtractionFunction-Tuple{MedEye3d.ForDisplayStructs.TextureSpec, MedEye3d.ForDisplayStructs.TextureSpec}","page":"MedEye3d.jl","title":"MedEye3d.CustomFragShad.getMasksSubtractionFunction","text":"used in order to enable subtracting one mask from the other - hence displaying  pixels where value of mask a is present but mask b not (order is important) automatically both masks will be set to be invisible and only the diffrence displayed\n\nIn order to provide maximum performance and avoid branching inside shader multiple shader programs will be attached and one choosed  that will use diffrence needed maskToSubtrastFrom,maskWeAreSubtracting - specifications o textures we are operating on \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.CustomFragShad.getNuclearMaskFunctions-Tuple{Vector{MedEye3d.ForDisplayStructs.TextureSpec}}","page":"MedEye3d.jl","title":"MedEye3d.CustomFragShad.getNuclearMaskFunctions","text":"Enable displaying for example nuclear medicine data by applying smoothly changing colors to floating point data 1)in confguration phase we need to have minimum, maximum and range of possible values associated with nuclear mask 2)as uniform we would need to have set of vec4's - those will be used  to display colors  3)colors will be set with algorithm presented below     a)range will be divided into sections (value ranges) wich numbers will equal  length of colors vector - 1     b)in each section  the output color will be mix of 2 colors one associated with this section and with next one          - contribution  of the color associated with given section will  vary from 100% at the begining of the section to 0%            in the end where 100% of color will be associated with color of next section\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.CustomFragShad.initialStrings-Tuple{}","page":"MedEye3d.jl","title":"MedEye3d.CustomFragShad.initialStrings","text":"some initial constants that are the same irrespective of textures\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.CustomFragShad.mainFuncString-Tuple{MedEye3d.ForDisplayStructs.TextureSpec, Vector{MedEye3d.ForDisplayStructs.TextureSpec}, MedEye3d.ForDisplayStructs.TextureSpec, MedEye3d.ForDisplayStructs.TextureSpec}","page":"MedEye3d.jl","title":"MedEye3d.CustomFragShad.mainFuncString","text":"controlling main function - basically we need to return proper FragColor which represents pixel color in given spot we generete separately r,g and b values by adding contributions from all textures    \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.CustomFragShad.setMaskInfluence-Tuple{MedEye3d.ForDisplayStructs.TextureSpec}","page":"MedEye3d.jl","title":"MedEye3d.CustomFragShad.setMaskInfluence","text":"Giving value from texture f the texture is set to be visible otherwise 0 \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.PrepareWindowHelpers","page":"MedEye3d.jl","title":"MedEye3d.PrepareWindowHelpers","text":"It stores set of functions that need to be composed in order to prepare GLFW window and  display verticies needed for texture  display\n\n\n\n\n\n","category":"module"},{"location":"#MedEye3d.PrepareWindowHelpers.controllWindowInput-Tuple{Any}","page":"MedEye3d.jl","title":"MedEye3d.PrepareWindowHelpers.controllWindowInput","text":"it will generally be invoked on GLFW.PollEvents()  in event loop and now depending on  what will be pressed or clicked it will lead to diffrent actions\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.PrepareWindowHelpers.createDAtaBuffer-Tuple{Any}","page":"MedEye3d.jl","title":"MedEye3d.PrepareWindowHelpers.createDAtaBuffer","text":"data is loaded into a buffer which passes it into thw GPU for futher processing      - here the data is just passing the positions of verticies     GLSTREAMDRAW the data is set only once and used by the GPU at most a few times.      GLSTATICDRAW the data is set only once and used many times.      GLDYNAMICDRAW the data is changed a lot and used many times.\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.PrepareWindowHelpers.createElementBuffer-Tuple{Any}","page":"MedEye3d.jl","title":"MedEye3d.PrepareWindowHelpers.createElementBuffer","text":"Similar to the VBO we bind the EBO and copy the indices into the buffer with glBufferData. \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.PrepareWindowHelpers.createVertexBuffer-Tuple{}","page":"MedEye3d.jl","title":"MedEye3d.PrepareWindowHelpers.createVertexBuffer","text":"vertex buffer keeping things simpler\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.PrepareWindowHelpers.encodeDataFromDataBuffer-Tuple{}","page":"MedEye3d.jl","title":"MedEye3d.PrepareWindowHelpers.encodeDataFromDataBuffer","text":"how data should be read from data buffer\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.PrepareWindowHelpers.glVertexAttribSetting-Tuple{Any}","page":"MedEye3d.jl","title":"MedEye3d.PrepareWindowHelpers.glVertexAttribSetting","text":"showing how openGL should read data from buffer in GPU in case of code like below it would mean:\n\nfirst parameter specifies which vertex attribute we want to configure Remember that we specified the location of the position vertex attribute in the vertex shader next argument specifies the size of the vertex attribute. The vertex attribute is a vec2 so it is composed of 2 values.  The third argument specifies the type of the data which is GLFLOAT next argument specifies if we want the data to be normalized. If we’re inputting integer data types like int, byte and we’ve set this to GLTRUE     The fifth argument is known as the stride and tells us the space between consecutive vertex attributes. Since the next set of position data is      located exactly 2 times the size of a float we could’ve also specified the stride as 0 to let OpenGL determine the stride      he last parameter is of type void* and thus requires that weird cast. This is the offset of where the position data begins in the buffer.\n\nglVertexAttribPointer positionAttribute, 2, GLFLOAT, false, 0, CNULL\n\nThe position data is stored as 32-bit  so 4 byte floating point values. \nEach position is composed of 2 of those values.\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.PrepareWindowHelpers.initializeWindow-Tuple{Int64, Int64}","page":"MedEye3d.jl","title":"MedEye3d.PrepareWindowHelpers.initializeWindow","text":"modified from ModernGL.jl github page  and GLFW page  stores primary \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.StructsManag","page":"MedEye3d.jl","title":"MedEye3d.StructsManag","text":"utilities for dealing data structs like FullScrollableDat or SingleSliceDat\n\n\n\n\n\n","category":"module"},{"location":"#MedEye3d.StructsManag.modifySliceFull!-Tuple{MedEye3d.DataStructs.FullScrollableDat, Int64, Vector{CartesianIndex{2}}, String, Any}","page":"MedEye3d.jl","title":"MedEye3d.StructsManag.modifySliceFull!","text":"modifies given slice in given coordinates of given data - queried by name data - full data we work on and modify coords - coordinates in a plane of chosen slice to modify (so list of x and y coords) value - value to set for given points return reference to modified slice\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ForDisplayStructs.getLocationDict-Tuple{Any}","page":"MedEye3d.jl","title":"MedEye3d.ForDisplayStructs.getLocationDict","text":"given Vector of TextureSpecs it creates dictionary where keys are associated names  and values are indicies where they are found in a list \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects","page":"MedEye3d.jl","title":"MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects","text":"Actor that is able to store a state to keep needed data for proper display\n\ncurrentDisplayedSlice::Int=1 # stores information what slice number we are currently displaying     mainForDisplayObjects:: forDisplayObjects=forDisplayObjects() # stores objects needed to  display using OpenGL and GLFW     onScrollData::FullScrollableDat = FullScrollableDat()     textureToModifyVec::Vector{TextureSpec}=[] # texture that we want currently to modify - if list is empty it means that we do not intend to modify any texture     isSliceChanged::Bool= false # set to true when slice is changed set to false when we start interacting with this slice - thanks to this we know that when we start drawing on one slice and change the slice the line would star a new on new slice     textDispObj::ForWordsDispStruct =ForWordsDispStruct()# set of objects and constants needed for text diplay     currentlyDispDat::SingleSliceDat =SingleSliceDat() # holds the data displayed or in case of scrollable data view for accessing it     calcDimsStruct::CalcDimsStruct=CalcDimsStruct()   #data for calculations of necessary constants needed to calculate window size , mouse position ...     valueForMasToSet::valueForMasToSetStruct=valueForMasToSetStruct() # value that will be used to set  pixels where we would interact with mouse     lastRecordedMousePosition::CartesianIndex{3} = CartesianIndex(1,1,1) # last position of the mouse  related to right click - usefull to know onto which slice to change when dimensions of scroll change     forUndoVector::AbstractArray=[] # holds lambda functions that when invoked will  undo last operations     maxLengthOfForUndoVector::Int64 = 10 # number controls how many step at maximum we can get back     isBusy::Base.Threads.Atomic{Bool}= Threads.Atomic{Bool}(0) # used to indicate by some functions that actor is busy and some interactions should be ceased\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.ForDisplayStructs.ForWordsDispStruct","page":"MedEye3d.jl","title":"MedEye3d.ForDisplayStructs.ForWordsDispStruct","text":"Holding necessery data to display text  - like font related\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.ForDisplayStructs.KeyboardCallbackSubscribable","page":"MedEye3d.jl","title":"MedEye3d.ForDisplayStructs.KeyboardCallbackSubscribable","text":"Object that enables managing input from keyboard - it stores the information also about needed keys wheather they are kept pressed   examples of keyboard input (raw GLFW input we process below)     action RELEASE GLFW.Action     key s StringPRESS     key s String     action PRESS GLFW.Action     key s StringRELEASE     key s String     action RELEASE GLFW.Action\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.ForDisplayStructs.KeyboardStruct","page":"MedEye3d.jl","title":"MedEye3d.ForDisplayStructs.KeyboardStruct","text":"Holding necessery data to controll keyboard shortcuts\n\nisCtrlPressed::Bool = false# left - scancode 37 right 105 - Int32 isShiftPressed::Bool = false # left - scancode 50 right 62- Int32 isAltPressed::Bool= false# left - scancode 64 right 108- Int32 isEnterPressed::Bool= false# scancode 36 isTAbPressed::Bool= false# isSpacePressed::Bool= false#  isF1Pressed::Bool= false isF2Pressed::Bool= false isF3Pressed::Bool= false\n\nlastKeysPressed::Vector{String}=[] # last pressed keys - it listenes to keys only if ctrl/shift or alt is pressed- it clears when we release those case or when we press enter #informations about what triggered sending this particular struct to the  actor mostRecentScanCode ::GLFW.Key=GLFW.KEYKP4 mostRecentKeyName ::String=\"\" mostRecentAction ::GLFW.Action= GLFW.RELEASE\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.ForDisplayStructs.MainImageUniforms","page":"MedEye3d.jl","title":"MedEye3d.ForDisplayStructs.MainImageUniforms","text":"Holding references to ..Uniforms used to controll main image\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.ForDisplayStructs.Mask","page":"MedEye3d.jl","title":"MedEye3d.ForDisplayStructs.Mask","text":"data needed for definition of mask  - data that will be displayed over main image  this struct is parametarized by type of 3 dimensional array that will be used  to store data\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.ForDisplayStructs.MaskTextureUniforms","page":"MedEye3d.jl","title":"MedEye3d.ForDisplayStructs.MaskTextureUniforms","text":"hold reference numbers that will be used to access and modify given uniform value In order to have easy fast access to the values set the most recent values will also be stored inside In order to improve usability  we will also save with what data type this mask is associated  for example Int, uint, float etc\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.ForDisplayStructs.MouseCallbackSubscribable","page":"MedEye3d.jl","title":"MedEye3d.ForDisplayStructs.MouseCallbackSubscribable","text":"struct that enables reacting to  the input  from mouse click  and drag the input will be      Cartesian index represening (x,y)      x and y position  of the mouse - will be recorded only if left mouse button is pressed or keep presssed\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.ForDisplayStructs.MouseStruct","page":"MedEye3d.jl","title":"MedEye3d.ForDisplayStructs.MouseStruct","text":"Holding necessery data to controll mouse interaction\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.ForDisplayStructs.ScrollCallbackSubscribable","page":"MedEye3d.jl","title":"MedEye3d.ForDisplayStructs.ScrollCallbackSubscribable","text":"struct that enables reacting to  the input from scrolling\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.ForDisplayStructs.TextureSpec","page":"MedEye3d.jl","title":"MedEye3d.ForDisplayStructs.TextureSpec","text":"Holding the data needed to create and  later reference the textures\n\nname::String=\"\"               #human readable name by which we can reference texture numb::Int32 =-1               #needed to enable swithing between textures generally convinient when between 0-9; needed only if texture is to be modified by mouse input whichCreated::Int32 =-1       #marks which one this texture was when created - so first in list second ... - needed for convinient accessing ..Uniforms in shaders isMainImage ::Bool = false  #true if this texture represents main image isNuclearMask ::Bool = false # used for example in case of nuclear imagiing studies isContinuusMask ::Bool = false # in case of masks if mask is continuus color display we set multiple colors in a vector color::RGB = RGB(0.0,0.0,0.0) #needed in case for the masks in order to establish the range of colors we are intrested in in case of binary mask there is no point to supply more than one color (supply Vector with length = 1) colorSet::Vector{RGB}=[]    #set of colors that can be used for mask with continous values strokeWidth::Int32 =Int32(3)#marking how thick should be the line that is left after acting with the mouse ...  isEditable::Bool =false     #if true we can modify given  texture using mouse interaction GLRtype::UInt32 =UInt32(0)           #GlRtype - for example GLR8UI or GLR16I OpGlType ::UInt32 =UInt32(0)          #open gl type - for example GLUNSIGNEDBYTE or GLSHORT actTextrureNumb ::UInt32 =UInt32(0)          #usefull to be able to activate the texture using GLActivetexture - with proper open GL constant associatedActiveNumer ::Int64 =Int64(0)          #usefull to be able to activate the texture using GLActivetexture - with proper open GL constant ID::Base.RefValue{UInt32} = Ref(UInt32(0))   #id of Texture isVisible::Bool= true       #if false it should be invisible  uniforms::TextureUniforms=MaskTextureUniforms()# holds values needed to control ..Uniforms in a shader minAndMaxValue::Vector{T} = []#entry one is minimum possible value for this mask, and second entry is maximum possible value for this mask\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.ForDisplayStructs.TextureUniforms","page":"MedEye3d.jl","title":"MedEye3d.ForDisplayStructs.TextureUniforms","text":"hold reference numbers that will be used to access and modify given uniform value in a shader\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.ForDisplayStructs.forDisplayObjects","page":"MedEye3d.jl","title":"MedEye3d.ForDisplayStructs.forDisplayObjects","text":"Defined in order to hold constant objects needed to display images  listOfTextSpecifications::Vector{TextureSpec} = [TextureSpec()] window = [] vertexshader::UInt32 =1 fragmentshader::UInt32=1 shader_program::UInt32=1 stopListening::Base.Threads.Atomic{Bool}= Threads.Atomic{Bool}(0)# enables unlocking GLFW context for futher actions vbo::UInt32 =1 #vertex buffer object id ebo::UInt32 =1 #element buffer object id mainImageUniforms::MainImageUniforms = MainImageUniforms()# struct with references to main image TextureIndexes::Dictionary{String, Int64}=Dictionary{String, Int64}()  #gives a way of efficient querying by supplying dictionary where key is a name we are intrested in and a key is index where it is located in our array numIndexes::Dictionary{Int32, Int64} =Dictionary{Int32, Int64}() # a way for fast query using assigned numbers gslsStr::String=\"\" # string giving information about used openg gl gsls version windowControlStruct::WindowControlStruct=WindowControlStruct()# holding data usefull to controll display window\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.DataStructs","page":"MedEye3d.jl","title":"MedEye3d.DataStructs","text":"structs helping managing and storing data\n\n\n\n\n\n","category":"module"},{"location":"#MedEye3d.DataStructs.getLocationDict-Tuple{Any}","page":"MedEye3d.jl","title":"MedEye3d.DataStructs.getLocationDict","text":"given Vector of tuples where first is string and second is RawDataToDisp it creates dictionary where keys are those strings - names and values are indicies where they are found\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.DataStructs.AnnotationStruct","page":"MedEye3d.jl","title":"MedEye3d.DataStructs.AnnotationStruct","text":"struct holding data usefull to controll mouse interaction with image      - so stroke width etc.\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.DataStructs.CalcDimsStruct","page":"MedEye3d.jl","title":"MedEye3d.DataStructs.CalcDimsStruct","text":"struct holding  data needed for calculating proper mouse position ,  getting proper size for the texture depending on image dimensions  getting into account  proportions of diffrent parts of display usefull stats for proper text display\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.DataStructs.DataToDisp","page":"MedEye3d.jl","title":"MedEye3d.DataStructs.DataToDisp","text":"hold Data that can be send to be displayed with required metadata\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.DataStructs.DataToScrollDims","page":"MedEye3d.jl","title":"MedEye3d.DataStructs.DataToScrollDims","text":"stores additional data about full dimensions of scrollable dat - this is necessery for switching slicing plane orientation efficiently\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.DataStructs.FullScrollableDat","page":"MedEye3d.jl","title":"MedEye3d.DataStructs.FullScrollableDat","text":"Data that can be displayed and scrolled (so we have multiple slices) struct is mutable becouse in case of the masks data can be changed multiple times and rapidly\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.DataStructs.RawDataToDisp","page":"MedEye3d.jl","title":"MedEye3d.DataStructs.RawDataToDisp","text":"hold raw Data that can be send to be displayed \n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.DataStructs.SimpleLineTextStruct","page":"MedEye3d.jl","title":"MedEye3d.DataStructs.SimpleLineTextStruct","text":"Struct holding line of text with some text metadata\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.DataStructs.SingleSliceDat","page":"MedEye3d.jl","title":"MedEye3d.DataStructs.SingleSliceDat","text":"Data for displaying single slice struct is mutable becouse in case of the masks data can be changed multiple times and rapidly   \n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.DataStructs.ThreeDimRawDat","page":"MedEye3d.jl","title":"MedEye3d.DataStructs.ThreeDimRawDat","text":"3 dimensional data for displaying single slice struct is mutable becouse in case of the masks data can be changed multiple times and rapidly   \n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.DataStructs.TwoDimRawDat","page":"MedEye3d.jl","title":"MedEye3d.DataStructs.TwoDimRawDat","text":"2 dimensional ata for displaying single slice struct is mutable becouse in case of the masks data can be changed multiple times and rapidly   \n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.DataStructs.WindowControlStruct","page":"MedEye3d.jl","title":"MedEye3d.DataStructs.WindowControlStruct","text":"struct holding data usefull to controll display window\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.DataStructs.valueForMasToSetStruct","page":"MedEye3d.jl","title":"MedEye3d.DataStructs.valueForMasToSetStruct","text":"simple struct that when passed is giving information about what should be current value we are setting to the mask\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.BasicStructs.ConfigurtationStruct","page":"MedEye3d.jl","title":"MedEye3d.BasicStructs.ConfigurtationStruct","text":"configuration struct that when passed will marks what kind of metrics we are intrested in \n\n\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.BasicStructs.ImageConstants","page":"MedEye3d.jl","title":"MedEye3d.BasicStructs.ImageConstants","text":"constants associated with image over which we will evaluate segmentations\n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.BasicStructs.ResultMetrics","page":"MedEye3d.jl","title":"MedEye3d.BasicStructs.ResultMetrics","text":"Struct holding all resulting metrics - if some metric was not calculated its value is just -1  \n\n\n\n\n\n","category":"type"},{"location":"#MedEye3d.ModernGlUtil","page":"MedEye3d.jl","title":"MedEye3d.ModernGlUtil","text":"copied from ModernGL github repository\n\n\n\n\n\n","category":"module"},{"location":"#MedEye3d.MaskDiffrence","page":"MedEye3d.jl","title":"MedEye3d.MaskDiffrence","text":"for case when we want to subtract two masks\n\n\n\n\n\n","category":"module"},{"location":"#MedEye3d.MaskDiffrence.displayMaskDiffrence-Tuple{MedEye3d.ForDisplayStructs.TextureSpec, MedEye3d.ForDisplayStructs.TextureSpec, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}}","page":"MedEye3d.jl","title":"MedEye3d.MaskDiffrence.displayMaskDiffrence","text":"SUBTRACTING MASKS used in order to enable subtracting one mask from the other - hence displaying  pixels where value of mask a is present but mask b not (order is important) automatically both masks will be set to be invisible and only the diffrence displayed\n\nIn order to achieve this  we need to have all of the samplers references stored in a list \n\nwe need to set both masks to invisible - it will be done from outside the shader\nwe set also from outside uniform marking visibility of diffrence to true\nalso from outside we need to set which texture to subtract from which we will achieve this by setting maskAtoSubtr and maskBtoSubtr int ..Uniforms  those integers will mark which samplers function will use\nin shader function will be treated as any other mask and will give contribution to output color multiplied by its visibility(0 or 1)    \ninside the function color will be defined as multiplication of two colors of mask A and mask B - colors will be acessed similarly to samplers\ncolor will be returned only if value associated with  maskA is greater than mask B and proportional to this difffrence\n\nIn order to provide maximum performance and avoid branching inside shader multiple shader programs will be attached and one choosed  that will use diffrence needed maskToSubtrastFrom,maskWeAreSubtracting - specifications o textures we are operating on \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.MaskDiffrence.processKeysInfo-Union{Tuple{G}, Tuple{T}, Tuple{DataTypesBasic.Identity{Tuple{DataTypesBasic.Identity{MedEye3d.ForDisplayStructs.TextureSpec{T}}, DataTypesBasic.Identity{MedEye3d.ForDisplayStructs.TextureSpec{G}}}}, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}, MedEye3d.ForDisplayStructs.KeyboardStruct}} where {T, G}","page":"MedEye3d.jl","title":"MedEye3d.MaskDiffrence.processKeysInfo","text":"for case when we want to subtract two masks\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.MaskDiffrence.undoDiffrence-Tuple{Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}, Any, Any}","page":"MedEye3d.jl","title":"MedEye3d.MaskDiffrence.undoDiffrence","text":"for case  we want to undo subtracting two masks\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.KeyboardVisibility","page":"MedEye3d.jl","title":"MedEye3d.KeyboardVisibility","text":"controls mask visibility responds to keyboard input\n\n\n\n\n\n","category":"module"},{"location":"#MedEye3d.KeyboardVisibility.processKeysInfo-Union{Tuple{T}, Tuple{DataTypesBasic.Identity{MedEye3d.ForDisplayStructs.TextureSpec{T}}, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}, MedEye3d.ForDisplayStructs.KeyboardStruct}} where T","page":"MedEye3d.jl","title":"MedEye3d.KeyboardVisibility.processKeysInfo","text":"processing information from keys - the instance of this function will be chosen on the basis mainly of multiple dispatch\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.KeyboardVisibility.setVisAndRender-Tuple{Bool, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects, MedEye3d.ForDisplayStructs.TextureUniforms}","page":"MedEye3d.jl","title":"MedEye3d.KeyboardVisibility.setVisAndRender","text":"sets  visibility and render the result to the screen\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.OtherKeyboardActions","page":"MedEye3d.jl","title":"MedEye3d.OtherKeyboardActions","text":"functions to controll stroke width , setting which texture is currently active and actions undoing\n\n\n\n\n\n","category":"module"},{"location":"#MedEye3d.OtherKeyboardActions.processKeysInfo-Union{Tuple{T}, Tuple{DataTypesBasic.Identity{Int64}, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}, MedEye3d.ForDisplayStructs.KeyboardStruct}, Tuple{DataTypesBasic.Identity{Int64}, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}, MedEye3d.ForDisplayStructs.KeyboardStruct, Bool}} where T","page":"MedEye3d.jl","title":"MedEye3d.OtherKeyboardActions.processKeysInfo","text":"in case we want to  get new number set for manual modifications     toBeSavedForBack - just marks weather we wat to save the info how to undo latest action     - false if we invoke it from undoing \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.OtherKeyboardActions.processKeysInfo-Union{Tuple{T}, Tuple{DataTypesBasic.Identity{MedEye3d.DataStructs.AnnotationStruct}, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}, MedEye3d.ForDisplayStructs.KeyboardStruct}, Tuple{DataTypesBasic.Identity{MedEye3d.DataStructs.AnnotationStruct}, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}, MedEye3d.ForDisplayStructs.KeyboardStruct, Bool}} where T","page":"MedEye3d.jl","title":"MedEye3d.OtherKeyboardActions.processKeysInfo","text":"when tab plus will be pressed it will increase stroke width when tab minus will be pressed it will increase stroke width\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.OtherKeyboardActions.processKeysInfoUndo-Union{Tuple{T}, Tuple{DataTypesBasic.Identity{Bool}, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}, MedEye3d.ForDisplayStructs.KeyboardStruct}} where T","page":"MedEye3d.jl","title":"MedEye3d.OtherKeyboardActions.processKeysInfoUndo","text":"In order to enable undoing last action we just invoke last function from list \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.WindowControll","page":"MedEye3d.jl","title":"MedEye3d.WindowControll","text":"functions that controll window - so basically treshords for mask display\n\n\n\n\n\n","category":"module"},{"location":"#MedEye3d.WindowControll.dispatchToFunctions-Tuple{MedEye3d.DataStructs.WindowControlStruct, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}, MedEye3d.ForDisplayStructs.KeyboardStruct}","page":"MedEye3d.jl","title":"MedEye3d.WindowControll.dispatchToFunctions","text":"Based on window struct and key info it will controll  which function should be invoked\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.WindowControll.getNewTresholdChangeValue-Tuple{MedEye3d.ForDisplayStructs.TextureSpec}","page":"MedEye3d.jl","title":"MedEye3d.WindowControll.getNewTresholdChangeValue","text":"helper function for setTextureWindow on the basis of given texture spec will give value proportional to the range\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.WindowControll.highTreshDown-Tuple{MedEye3d.DataStructs.WindowControlStruct, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}, MedEye3d.ForDisplayStructs.TextureSpec, MedEye3d.DataStructs.WindowControlStruct}","page":"MedEye3d.jl","title":"MedEye3d.WindowControll.highTreshDown","text":"sets upper treshold and decrese it\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.WindowControll.highTreshUp-Tuple{MedEye3d.DataStructs.WindowControlStruct, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}, MedEye3d.ForDisplayStructs.TextureSpec, MedEye3d.DataStructs.WindowControlStruct}","page":"MedEye3d.jl","title":"MedEye3d.WindowControll.highTreshUp","text":"sets upper treshold and Increase it\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.WindowControll.lowTreshDown-Tuple{MedEye3d.DataStructs.WindowControlStruct, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}, MedEye3d.ForDisplayStructs.TextureSpec, MedEye3d.DataStructs.WindowControlStruct}","page":"MedEye3d.jl","title":"MedEye3d.WindowControll.lowTreshDown","text":"sets lower treshold and decrese it\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.WindowControll.lowTreshUp-Tuple{MedEye3d.DataStructs.WindowControlStruct, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}, MedEye3d.ForDisplayStructs.TextureSpec, MedEye3d.DataStructs.WindowControlStruct}","page":"MedEye3d.jl","title":"MedEye3d.WindowControll.lowTreshUp","text":"sets lower treshold and Increase it\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.WindowControll.maskContrDown-Tuple{MedEye3d.DataStructs.WindowControlStruct, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}, MedEye3d.ForDisplayStructs.TextureSpec, MedEye3d.DataStructs.WindowControlStruct}","page":"MedEye3d.jl","title":"MedEye3d.WindowControll.maskContrDown","text":"sets mask contribution and  decrese it\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.WindowControll.maskContrUp-Tuple{MedEye3d.DataStructs.WindowControlStruct, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}, MedEye3d.ForDisplayStructs.TextureSpec, MedEye3d.DataStructs.WindowControlStruct}","page":"MedEye3d.jl","title":"MedEye3d.WindowControll.maskContrUp","text":"sets mask contribution and increase it\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.WindowControll.primaryModificationsOfWindContr-Tuple{MedEye3d.DataStructs.WindowControlStruct, MedEye3d.ForDisplayStructs.KeyboardStruct}","page":"MedEye3d.jl","title":"MedEye3d.WindowControll.primaryModificationsOfWindContr","text":"On the basis of the input WindowControlStruct and keyInfo it makes necessary primary modifications to WindowControlStruct \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.WindowControll.processKeysInfo-Union{Tuple{T}, Tuple{DataTypesBasic.Identity{MedEye3d.DataStructs.WindowControlStruct}, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}, MedEye3d.ForDisplayStructs.KeyboardStruct}, Tuple{DataTypesBasic.Identity{MedEye3d.DataStructs.WindowControlStruct}, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}, MedEye3d.ForDisplayStructs.KeyboardStruct, Bool}} where T","page":"MedEye3d.jl","title":"MedEye3d.WindowControll.processKeysInfo","text":"KEYF1 - will display wide window for bone Int32(1000),Int32(-1000) KEYF2 - will display window for soft tissues Int32(400),Int32(-200) KEYF3 - will display wide window for lung viewing  Int32(0),Int32(-1000) KEYF4,  KEYF5 -     sets minimum (F4) and maximum (KEYF5) value for display (with combination of + and minus signs - to increase or decrease given treshold) -          in case of continuus colors it will clamp values - so all above max will be equaled to max ; and min if smallert than min         in case of main CT mask - it will controll min shown white and max shown black         in case of maks with single color associated we will step data so if data is outside the rande it will return 0 - so will not affect display KEY_F6 - controlls contribution  of given mask to the overall image - maximum value is 1 minimum 0 if we have 3 masks and all control contribution is set to 1 and all are visible their corresponding influence to pixel color is 33%       if plus is pressed it will increse contribution by 0.1         if minus is pressed it will decrease contribution by 0.1  \n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.WindowControll.setTextureWindow-Tuple{MedEye3d.ForDisplayStructs.TextureSpec, Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}}","page":"MedEye3d.jl","title":"MedEye3d.WindowControll.setTextureWindow","text":"sets minimum and maximum value for display -      in case of continuus colors it will clamp values - so all above max will be equaled to max ; and min if smallert than min     in case of main CT mask - it will controll min shown white and max shown black     in case of maks with single color associated we will step data so if data is outside the rande it will return 0 - so will not affect display\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.WindowControll.setmainWindow-Tuple{Rocket.SyncActor{Any, MedEye3d.ForDisplayStructs.ActorWithOpenGlObjects}, MedEye3d.DataStructs.WindowControlStruct}","page":"MedEye3d.jl","title":"MedEye3d.WindowControll.setmainWindow","text":"set main window - min shown white and max shown black on the basis of textur data and windowStruct\n\n\n\n\n\n","category":"method"},{"location":"#MedEye3d.ChangePlane","page":"MedEye3d.jl","title":"MedEye3d.ChangePlane","text":"controls changing plane for example from transverse to saggital ...\n\n\n\n\n\n","category":"module"}]
}
